"use client";

import { useCallback, useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { contracts, passethub } from "@polkadot-api/descriptors";
import { createReviveSdk } from "@polkadot-api/sdk-ink";
import { createClient, FixedSizeBinary, HexString } from "polkadot-api";
import { withPolkadotSdkCompat } from "polkadot-api/polkadot-sdk-compat";
import { getWsProvider } from "polkadot-api/ws-provider/web";
import { usePolkadotExtension } from "@/providers/polkadot-extension-provider";
import { useDeployTreasury } from "@/hooks/use-deploy-treasury";

import { useQuery } from "convex/react";
import { api } from "@/convex/_generated/api";

const CONTRACT_NETWORK = "wss://testnet-passet-hub.polkadot.io";

export default function TestDeployPage() {
  const { selectedAccount } = usePolkadotExtension();
  const {
    deployTreasury,
    contractAddress,
    isLoading,
    error,
    isSuccess,
    reset,
  } = useDeployTreasury();

  const treasuries = useQuery(
    api.treasuries.listByOwner,
    selectedAccount ? { owner: selectedAccount.address } : "skip"
  );

  const [contractInstance, setContractInstance] = useState<HexString | null>(
    // "0x9239d5E58180d68a33cAEdF40319aBC892647835" // working with 30 payouts,
    "0x3de3c933117af3864edd176a5ab1921e6d312c8e"
  );

  // Update contract instance when deployment succeeds
  useEffect(() => {
    if (isSuccess && contractAddress) {
      setContractInstance(contractAddress);
    }
  }, [isSuccess, contractAddress]);

  const handleRead = async () => {
    try {
      if (!selectedAccount) {
        throw new Error("No account selected");
      }

      // Initialize client
      const client = createClient(
        withPolkadotSdkCompat(getWsProvider(CONTRACT_NETWORK))
      );
      const typedApi = client.getTypedApi(passethub);

      const treasurySdk = createReviveSdk(typedApi, contracts.treasury);

      if (!contractInstance) {
        throw new Error("No contract instance");
      }

      const treasuryContract = treasurySdk.getContract(contractInstance);

      console.log("Get pending payouts for account");
      // const result = await treasuryContract.query("get_pending_payouts", {
      //   origin: selectedAccount.address,
      // });

      const payoutIds = await treasuryContract.query("get_pending_payout_ids", {
        origin: selectedAccount.address,
      });

      // console.log("result", result.value.response);
      console.log("payoutIds", payoutIds.value.response);
    } catch (err) {
      console.error("Read error:", err);
    }
  };

  const handleAddPayout = useCallback(async () => {
    try {
      if (!selectedAccount) {
        throw new Error("No account selected");
      }
      if (!contractInstance) {
        throw new Error("No contract instance");
      }

      console.log(
        "Adding payout from",
        selectedAccount.address,
        "to",
        contractInstance
      );

      const client = createClient(
        withPolkadotSdkCompat(getWsProvider(CONTRACT_NETWORK))
      );
      const typedApi = client.getTypedApi(passethub);

      const treasurySdk = createReviveSdk(typedApi, contracts.treasury);

      const treasuryContract = treasurySdk.getContract(contractInstance);

      const dryRunResult = await treasuryContract.query("add_payout", {
        origin: selectedAccount.address,
        data: {
          to: FixedSizeBinary.fromHex(
            "0x00000013100000000000000000000000000000013"
          ),
          amount: BigInt(13),
        },
      });

      if (dryRunResult.success) {
        console.log("add_payout", dryRunResult.value.response);
        console.log("events", dryRunResult.value.events);

        // The dry-run result also has a method to get the transaction to send the same message to the contract.
        const addPayoutTxResult = await dryRunResult.value
          .send()
          .signAndSubmit(selectedAccount.polkadotSigner);
        if (addPayoutTxResult.ok) {
          console.log("block", addPayoutTxResult.block);
          // The events generated by this contract can also be filtered using `filterEvents`:
          console.log(
            "events",
            treasuryContract.filterEvents(addPayoutTxResult.events)
          );
        } else {
          console.log("error", addPayoutTxResult.dispatchError);
        }
      } else {
        console.log("error", dryRunResult.value);
      }
    } catch (err) {
      console.error("Add payout error:", err);
    }
  }, [selectedAccount, contractInstance]);

  const handleAddPayoutBatch = useCallback(async () => {
    try {
      if (!selectedAccount) {
        throw new Error("No account selected");
      }
      if (!contractInstance) {
        throw new Error("No contract instance");
      }

      const client = createClient(
        withPolkadotSdkCompat(getWsProvider(CONTRACT_NETWORK))
      );
      const typedApi = client.getTypedApi(passethub);

      const treasurySdk = createReviveSdk(typedApi, contracts.treasury);

      const treasuryContract = treasurySdk.getContract(contractInstance);

      // add 10 payouts
      const payouts: [FixedSizeBinary<20>, bigint][] = Array.from(
        { length: 10 },
        (_, i) => [
          FixedSizeBinary.fromHex(
            "0x00000013100000000000000000000000000000013"
          ),
          BigInt(i),
        ]
      );

      const dryRunResult = await treasuryContract.query("add_payout_batch", {
        origin: selectedAccount.address,
        data: {
          payouts,
        },
      });

      if (dryRunResult.success) {
        console.log("add_payout_batch", dryRunResult.value.response);
        console.log("events", dryRunResult.value.events);

        const addPayoutBatchTxResult = await dryRunResult.value
          .send()
          .signSubmitAndWatch(selectedAccount.polkadotSigner)
          .subscribe((txEvent) => {
            console.log("txEvent:", txEvent);
            if (
              txEvent.type === "finalized" ||
              (txEvent.type === "txBestBlocksState" && txEvent.found)
            ) {
              if (txEvent.ok) {
                console.log("block", txEvent.block);
                console.log(
                  "events",
                  treasuryContract.filterEvents(txEvent.events)
                );
              } else {
                console.log("error", txEvent.dispatchError);
              }
            }
          });
      } else {
        console.log("error", dryRunResult.value);
      }
    } catch (err) {
      console.error("Add payout batch error:", err);
    }
  }, [selectedAccount, contractInstance]);

  const handleGetBalance = useCallback(async () => {
    if (!contractInstance) {
      throw new Error("No contract instance");
    }

    const client = createClient(
      withPolkadotSdkCompat(getWsProvider(CONTRACT_NETWORK))
    );
    const typedApi = client.getTypedApi(passethub);

    const treasurySdk = createReviveSdk(typedApi, contracts.treasury);

    const treasuryContract = treasurySdk.getContract(contractInstance);

    const balance = await treasuryContract.query("get_balance", {
      origin: contractInstance,
    });

    console.log("balance", balance.value.response);
  }, [contractInstance]);

  return (
    <div className="flex flex-col gap-4 p-4">
      <pre>
        treasuries:{" "}
        {treasuries ? JSON.stringify(treasuries, null, 2) : "No treasuries"}
      </pre>
      <pre>contractInstance: {JSON.stringify(contractInstance, null, 2)}</pre>
      <Button
        //   onClick={() =>
        //     deployTreasury({
        //       name: "Test Treasury",
        //     })
        //   }
        disabled={isLoading}
      >
        {isLoading ? "Deploying..." : "Deploy Contract"}
      </Button>
      <Button onClick={handleRead} disabled={isLoading || !contractInstance}>
        Read Contract {contractInstance ? "✅" : "❌"}
      </Button>
      <Button
        onClick={handleAddPayout}
        disabled={isLoading || !contractInstance}
      >
        Add Payout
      </Button>
      <Button
        onClick={handleAddPayoutBatch}
        disabled={isLoading || !contractInstance}
      >
        Add Payout Batch (10)
      </Button>
      <Button
        onClick={handleGetBalance}
        disabled={isLoading || !contractInstance}
      >
        Get Balance
      </Button>
      {error && <p className="text-sm text-red-500">{error}</p>}
    </div>
  );
}
