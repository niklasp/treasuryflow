"use client";

import { useCallback, useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { contracts, passethub } from "@polkadot-api/descriptors";
import { createReviveSdk } from "@polkadot-api/sdk-ink";
import { createClient, FixedSizeBinary, HexString } from "polkadot-api";
import { withPolkadotSdkCompat } from "polkadot-api/polkadot-sdk-compat";
import { getWsProvider } from "polkadot-api/ws-provider/web";
import { usePolkadotExtension } from "@/providers/polkadot-extension-provider";
import { useDeployTreasury } from "@/hooks/use-deploy-treasury";

const CONTRACT_NETWORK = "wss://testnet-passet-hub.polkadot.io";

export default function TestDeployPage() {
  const { selectedAccount } = usePolkadotExtension();
  const {
    deployTreasury,
    contractAddress,
    isLoading,
    error,
    isSuccess,
    reset,
  } = useDeployTreasury();

  const [contractInstance, setContractInstance] = useState<HexString | null>(
    // "0x9239d5E58180d68a33cAEdF40319aBC892647835" // working with 30 payouts,
    "0x49edc72339bf69d594d64a169979e8d61b8414c3"
  );

  // Update contract instance when deployment succeeds
  useEffect(() => {
    if (isSuccess && contractAddress) {
      setContractInstance(contractAddress);
    }
  }, [isSuccess, contractAddress]);

  const handleRead = async () => {
    try {
      if (!selectedAccount) {
        throw new Error("No account selected");
      }

      // Initialize client
      const client = createClient(
        withPolkadotSdkCompat(getWsProvider(CONTRACT_NETWORK))
      );
      const typedApi = client.getTypedApi(passethub);

      const treasurySdk = createReviveSdk(typedApi, contracts.treasury);

      if (!contractInstance) {
        throw new Error("No contract instance");
      }

      const treasuryContract = treasurySdk.getContract(contractInstance);

      console.log("Get pending payouts for account");
      // const result = await treasuryContract.query("get_pending_payouts", {
      //   origin: selectedAccount.address,
      // });

      const payoutIds = await treasuryContract.query("get_pending_payout_ids", {
        origin: selectedAccount.address,
      });

      // console.log("result", result.value.response);
      console.log("payoutIds", payoutIds.value.response);
    } catch (err) {
      console.error("Read error:", err);
    }
  };

  const handleAddPayout = useCallback(async () => {
    try {
      if (!selectedAccount) {
        throw new Error("No account selected");
      }
      if (!contractInstance) {
        throw new Error("No contract instance");
      }

      console.log(
        "Adding payout from",
        selectedAccount.address,
        "to",
        contractInstance
      );

      const client = createClient(
        withPolkadotSdkCompat(getWsProvider(CONTRACT_NETWORK))
      );
      const typedApi = client.getTypedApi(passethub);

      const treasurySdk = createReviveSdk(typedApi, contracts.treasury);

      const treasuryContract = treasurySdk.getContract(contractInstance);

      const dryRunResult = await treasuryContract.query("add_payout", {
        origin: selectedAccount.address,
        data: {
          to: FixedSizeBinary.fromHex(
            "0x00000013100000000000000000000000000000013"
          ),
          amount: BigInt(13),
        },
      });

      if (dryRunResult.success) {
        console.log("add_payout", dryRunResult.value.response);
        console.log("events", dryRunResult.value.events);

        // The dry-run result also has a method to get the transaction to send the same message to the contract.
        const addPayoutTxResult = await dryRunResult.value
          .send()
          .signAndSubmit(selectedAccount.polkadotSigner);
        if (addPayoutTxResult.ok) {
          console.log("block", addPayoutTxResult.block);
          // The events generated by this contract can also be filtered using `filterEvents`:
          console.log(
            "events",
            treasuryContract.filterEvents(addPayoutTxResult.events)
          );
        } else {
          console.log("error", addPayoutTxResult.dispatchError);
        }
      } else {
        console.log("error", dryRunResult.value);
      }
    } catch (err) {
      console.error("Add payout error:", err);
    }
  }, [selectedAccount, contractInstance]);

  const handleAddPayoutBatch = useCallback(async () => {
    try {
      if (!selectedAccount) {
        throw new Error("No account selected");
      }
      if (!contractInstance) {
        throw new Error("No contract instance");
      }

      const client = createClient(
        withPolkadotSdkCompat(getWsProvider(CONTRACT_NETWORK))
      );
      const typedApi = client.getTypedApi(passethub);

      const treasurySdk = createReviveSdk(typedApi, contracts.treasury);

      const treasuryContract = treasurySdk.getContract(contractInstance);

      // add 10 payouts
      const payouts: [FixedSizeBinary<20>, bigint][] = Array.from(
        { length: 10 },
        (_, i) => [
          FixedSizeBinary.fromHex(
            "0x00000013100000000000000000000000000000013"
          ),
          BigInt(i),
        ]
      );

      const dryRunResult = await treasuryContract.query("add_payout_batch", {
        origin: selectedAccount.address,
        data: {
          payouts,
        },
      });

      if (dryRunResult.success) {
        console.log("add_payout_batch", dryRunResult.value.response);
        console.log("events", dryRunResult.value.events);

        const addPayoutBatchTxResult = await dryRunResult.value
          .send()
          .signAndSubmit(selectedAccount.polkadotSigner, {
            at: "best",
          });
        if (addPayoutBatchTxResult.ok) {
          console.log("block", addPayoutBatchTxResult.block);
          console.log(
            "events",
            treasuryContract.filterEvents(addPayoutBatchTxResult.events)
          );
        } else {
          console.log("error", addPayoutBatchTxResult.dispatchError);
        }
      } else {
        console.log("error", dryRunResult.value);
      }
    } catch (err) {
      console.error("Add payout batch error:", err);
    }
  }, [selectedAccount, contractInstance]);

  return (
    <div className="flex flex-col gap-4 p-4">
      <pre>contractInstance: {JSON.stringify(contractInstance, null, 2)}</pre>
      <Button onClick={() => deployTreasury()} disabled={isLoading}>
        {isLoading ? "Deploying..." : "Deploy Contract"}
      </Button>
      <Button onClick={handleRead} disabled={isLoading || !contractInstance}>
        Read Contract {contractInstance ? "✅" : "❌"}
      </Button>
      <Button
        onClick={handleAddPayout}
        disabled={isLoading || !contractInstance}
      >
        Add Payout
      </Button>
      <Button
        onClick={handleAddPayoutBatch}
        disabled={isLoading || !contractInstance}
      >
        Add Payout Batch (10)
      </Button>
      {error && <p className="text-sm text-red-500">{error}</p>}
    </div>
  );
}
